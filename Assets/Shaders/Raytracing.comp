#version 450
#extension GL_GOOGLE_include_directive : require

#include "./include/random.glsl"
#include "./include/constants.glsl"
#include "./include/color.glsl"

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

layout(binding = 1, std140) uniform SceneData{
    mat4 camProjection;
    mat4 camView;
    mat4 camInvProjection;
    mat4 camInvView;
    vec3 color;
    uint frameIndex;
    uint useAccumulationTexture;
    uint accumFrameIndex;
    uint maxBounces;
} sceneData;

layout(binding = 2, rgba32f) uniform image2D accumulationTexture;

struct triangle {
    vec3 v0;
    vec3 v1;
    vec3 v2;
    vec3 n0;
    vec3 n1;
    vec3 n2;
    uint materialFlag;
};

struct vertex {
    vec3 position;
    vec3 normal;
    vec2 uv;
    uint materialFlag;
};

layout(binding = 3, std140) readonly buffer Triangles{
    vertex vertecies[];
};

layout(binding = 4) readonly buffer Indecies{
    uint indecies[];
};

struct BHVNode {
    vec3 aabbMin;
    vec3 aabbMax;
    uint left;
    // uint32_t right = left + 1; as they are stored consequtevly
    uint startIndex;
    uint indeciesCount;
};

layout(binding = 5, std140) readonly buffer BHVNodes{
    BHVNode nodes[];
};

struct ray {
    vec3 origin;
    vec3 direction;
};

struct HitResult {
    vec3 hitPoint;
    vec3 normal;
    float hitDistance;
    bool frontFace;
    uint materialFlag;
};

struct sphere {
    vec3 center;
    float radius;
    uint materialFlag;
};

triangle getTriangle(uint startIndex) {
    return triangle(
        vertecies[indecies[startIndex]].position,
        vertecies[indecies[startIndex + 1]].position,
        vertecies[indecies[startIndex + 2]].position,
        vertecies[indecies[startIndex]].normal,
        vertecies[indecies[startIndex + 1]].normal,
        vertecies[indecies[startIndex + 2]].normal,
        vertecies[indecies[startIndex]].materialFlag
    );
}

bool hitSphere(sphere sphere, ray ray, inout HitResult hitResult){
    //solve sphere equation
    vec3 origin = sphere.center - ray.origin;
    
    float a = dot(ray.direction, ray.direction);
    float h = dot(origin, ray.direction);
    float c = dot(origin, origin) - sphere.radius * sphere.radius;

    float discriminant = h * h - a * c;
    if(discriminant < 0) return false;
    
    float sqrtDiscriminant = sqrt(discriminant);

    //calculate hitpoint and normal
    float t0 = (h - sqrtDiscriminant / a);
    if(t0 < 0.001 || t0 > 1000) 
    {
        t0 = (h + sqrtDiscriminant / a);
        if(t0 < 0.001 || t0 > 1000) return false;
    }


    vec3 hitPoint = ray.origin + t0 * ray.direction;
    vec3 normal = normalize(hitPoint - sphere.center);

    hitResult.hitDistance = t0;
    hitResult.hitPoint = hitPoint;
    hitResult.frontFace = dot(ray.direction, normal) < 0;
    hitResult.normal = hitResult.frontFace ? normal : -normal;
    hitResult.materialFlag = sphere.materialFlag;

    return true;
}

bool hitTriangle(triangle tri, ray ray, inout HitResult hitResult) {
    vec3 v0v1 = tri.v1 - tri.v0;
    vec3 v0v2 = tri.v2 - tri.v0;
    vec3 pVec = cross(ray.direction, v0v2);
    float det = dot(v0v1, pVec);
    
    if(abs(det) < epsilon) 
    {
        return false;
    } 
    
    float invDet = 1 / det;
    vec3 tVec = ray.origin - tri.v0;
    float u = dot(tVec, pVec) * invDet;
    vec3 qVec = cross(tVec, v0v1);
    float v = dot(ray.direction, qVec) * invDet;
    
    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) return false;

    float t = dot(v0v2, qVec) * invDet;
    if (t <= 0.001) return false;
    
    hitResult.hitDistance = t;
    hitResult.hitPoint = ray.origin + t * ray.direction;
    hitResult.normal = vec3(u,v,1-u-v);
    hitResult.normal = tri.n1 * u + tri.n2 * v + tri.n0 * (1 - u - v);
    
    if(det < 0) 
        hitResult.normal *= -1;

    hitResult.frontFace = dot(ray.direction, hitResult.normal) < 0;
    hitResult.materialFlag = tri.materialFlag;
    
    return true;
}

bool hitAABB(vec3 aabbMin, vec3 aabbMax, ray ray) {

    if(ray.direction.x == 0 && (ray.origin.x < aabbMin.x || ray.origin.x > aabbMax.x)) return false;
    if(ray.direction.y == 0 && (ray.origin.y < aabbMin.y || ray.origin.y > aabbMax.y)) return false;
    if(ray.direction.z == 0 && (ray.origin.z < aabbMin.z || ray.origin.z > aabbMax.z)) return false;

    float tmin = infinity;
    float tmax = 0;

    vec3 invDir = 1.0 / ray.direction;
    vec3 t0 = (aabbMin - ray.origin) * invDir;
    vec3 t1 = (aabbMax - ray.origin) * invDir;
    vec3 tminv = min(t0, t1);
    vec3 tmaxv = max(t0, t1);

    tmin = max(tminv.x, max(tminv.y, tminv.z));
    tmax = min(tmaxv.x, min(tmaxv.y, tmaxv.z));
    
    return tmax >= tmin && tmax > 0;
}

bool hitBHVTree(uint nodeIndex, ray ray, inout HitResult hitResult) 
{
    uint nodeQueue[32];
    nodeQueue[0] = nodeIndex;
    uint quelenght = 1;

    float closestT = infinity;
    bool hit = false;
    HitResult currentHit;

    while(quelenght > 0)
    {
        BHVNode node = nodes[nodeQueue[quelenght - 1]];
        quelenght--;

        if (!hitAABB(node.aabbMin, node.aabbMax, ray)) 
        {
            continue;
        }

        if (node.indeciesCount > 0) {
            
            for(int i = 0; i < node.indeciesCount; i+= 3)
            {
                triangle tri = getTriangle(node.startIndex + i);
                if (hitTriangle(tri, ray, currentHit))
                {
                    hit = true;
                    if (currentHit.hitDistance < closestT)
                    {
                        closestT = currentHit.hitDistance;
                        hitResult = currentHit;
                    }
                }
            }

            continue;
        }

        nodeQueue[quelenght++] = node.left;
        nodeQueue[quelenght++] = node.left + 1;
    }

    return hit;
}

void hitBHVTreeDebug(uint nodeIndex, ray ray, inout HitResult hitResult, inout vec3 color) 
{
    uint nodeQueue[32];
    nodeQueue[0] = nodeIndex;
    uint quelenght = 1;

    float closestT = infinity;
    bool hit = false;
    HitResult currentHit;
    uint counter = 0;

    uint skipCounter = 3;
    uint maxCounter = 32;

    while(quelenght > 0)
    {
        BHVNode node = nodes[nodeQueue[quelenght - 1]];
        quelenght--;

        if (!hitAABB(node.aabbMin, node.aabbMax, ray)) 
        {
            continue;
        }

        if(counter < maxCounter)
        {
            counter++;
            //color *= vec3(0.97, 0.36, 0.18);
        }
            

        if (node.indeciesCount > 0) {
            continue;
        }

        nodeQueue[quelenght++] = node.left;
        nodeQueue[quelenght++] = node.left + 1;
    }

    if(counter > skipCounter)
    {
        color = mix(vec3(0.16, 0.99, 0.18), vec3(0.97, 0.36, 0.18), float(counter - skipCounter) / 32.0);
    }
}

vec3 ray_refract(vec3 rayDirection, vec3 surfaceNormal, float etai_over_etat) {
    float cos_theta = min(dot(-rayDirection, surfaceNormal), 1.0);
    vec3 r_out_parallel = etai_over_etat * (rayDirection + cos_theta * surfaceNormal);
    vec3 r_out_perp = -sqrt(abs(1.0 - dot(r_out_parallel, r_out_parallel))) * surfaceNormal;
    return r_out_parallel + r_out_perp;
}

float reflectance(float cosine, float refraction_index) {
    // Use Schlick's approximation for reflectance.
    float r0 = (1.0 - refraction_index) / (1.0 + refraction_index);
    r0 = r0*r0;
    return r0 + (1.0-r0)*pow((1.0 - cosine),5);
}

void Scater(HitResult hit, inout ray ray, inout vec3 attenuation)
{
    switch(hit.materialFlag)
    {
        //lambertian
        case 0:
            attenuation *= vec3(0.8, 0.8, 0.0); //albedo
            ray.origin = hit.hitPoint + hit.normal * 0.01;
            ray.direction = hit.normal + randomUnitVector();
            if(dot(ray.direction, hit.normal) < 0.0001) 
                ray.direction = hit.normal;
            break;

        //metal            
        case 1:
            float fuzz = 0.01;
            attenuation *= vec3(0.8, 0.8, 0.0); //albedo
            ray.origin = hit.hitPoint + hit.normal * 0.01;
            ray.direction = normalize(reflect(ray.direction, hit.normal)) + fuzz * randomUnitVector();
            break;

        //glass
        case 2:
            float refractionIndex = 1.0 / 1.33;
            //attenuation not changed
            ray.origin = hit.hitPoint;

            float ri = hit.frontFace ? 1.0 / refractionIndex : refractionIndex;
            vec3 unitDir = normalize(ray.direction);
            float cosTheta = min(dot(-unitDir, hit.normal), 1.0);
            float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

            bool cannotRefract = ri * sinTheta > 1.0;
            vec3 direction = cannotRefract || reflectance(cosTheta, ri) > hash1() ? reflect(unitDir, hit.normal) : ray_refract(unitDir, hit.normal, ri);
            ray.direction = direction;
        break;
    }
}
vec3 GetRayDirection(vec2 screenCord)
{
    vec4 target = sceneData.camInvProjection * vec4(screenCord, 1.0, 1.0);
    vec3 dir = vec3(sceneData.camInvView * vec4(normalize(vec3(target.xyz / target.w)), 0.0));
    return normalize(dir);
}

vec3 TraceRay(ray ray)
{
    sphere spheres[3];

    spheres[0] = sphere(vec3(1.8, 0.0, -0.1), 0.5, 0);
    spheres[1] = sphere(vec3(-1.8, 0.0, -0.1), 0.5, 2);
    spheres[2] = sphere(vec3(0,-100.5, -1), 100, 0);
    
    uint maxBounces = sceneData.maxBounces;
    vec3 finalColor = vec3(0);
    vec3 color = vec3(1);
        
    for(int d = 0; d < maxBounces; d++) 
    {
        HitResult currentHit;
        HitResult closestHit;
        bool hit = false;
        float closestT = infinity;
        

        for(int i = 0; i < spheres.length(); i++)
        {
            if (!hitSphere(spheres[i], ray, currentHit) || currentHit.hitDistance >= closestT || currentHit.hitDistance < 0.001)
                continue;

            hit = true;
            closestT = currentHit.hitDistance;
            closestHit = currentHit;
        }

        //hitBHVTreeDebug(0, ray, currentHit, color);
        if(hitBHVTree(0, ray, currentHit) && currentHit.hitDistance < closestT && currentHit.hitDistance > 0.001)
        {
            hit = true;
            closestT = currentHit.hitDistance;
            closestHit = currentHit;
        }

        // for(int i = 0; i < indecies.length(); i+= 3)
        // {
        //     triangle tri = getTriangle(i);
        //     if (hitTriangle(tri, ray, currentHit) && currentHit.hitDistance < closestT && currentHit.hitDistance > 0.001)
        //     {
        //         hit = true;
        //         closestT = currentHit.hitDistance;
        //         closestHit = currentHit;
        //     }
        // }

        if (hit) 
        {
            Scater(closestHit, ray, color);
        }
        else 
        {
            vec3 unitDir = normalize(ray.direction);
            float a = 0.5 * (unitDir.y + 1.0);
            vec3 skyColor =  (1.0 - a * vec3(1) + a * sceneData.color);
            finalColor = color * skyColor;
            break;
        }        
    }
    return finalColor;
}


void main() 
{
    vec2 imageSize = vec2(imageSize(resultImage));
    ivec2 textureCoord = ivec2(gl_GlobalInvocationID.xy);
    
    //calculate uv coords
    vec2 uv = textureCoord / imageSize.xy;
    vec2 screenCord = uv * 2 - 1;
    screenCord.y *= -1;
    
    // modify random seed
    gState *= floatBitsToUint(uv.y * uv.x / 1000) * textureCoord.x * sceneData.frameIndex;

    vec3 origin = sceneData.camInvView[3].xyz;

    //anti aliasing
    uint samplesPerPixel = 4;
    float influence = 0.0025;
    vec3 frameColor = vec3(0);    
    for(int i = 0; i < samplesPerPixel; i++) {
        vec3 dir = GetRayDirection(screenCord) + influence * hash3();
        ray ray = ray(origin, dir);
        frameColor += TraceRay(ray);
    }
    frameColor /= samplesPerPixel;

    vec3 color = frameColor.rgb;
    int useAcc = int(sceneData.useAccumulationTexture);
    int firstAcc = int(sceneData.accumFrameIndex != 0);

    vec3 currentColor = frameColor + useAcc * imageLoad(accumulationTexture, ivec2(gl_GlobalInvocationID.xy)).rgb;

    if(firstAcc == 1)
    {
        imageStore(accumulationTexture, ivec2(gl_GlobalInvocationID.xy), vec4(currentColor, 1));
    }
        
    color = currentColor.rgb / (useAcc * sceneData.accumFrameIndex + 1);
    color = gamma_correction(color);
    color = clamp(color, 0, 1);

    imageStore(resultImage, textureCoord, vec4(color.rgb, 1));
}